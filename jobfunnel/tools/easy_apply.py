import csv
import subprocess
import random
import webbrowser
import sys
import argparse
import os


def extract_link(row):
    """
    extracts the application link from a csv row.
    """
    return row[len(row)-4]


def duplicate_csv(new_file, old_file):
    """
    This takes the contents of old_file and dumps them onto new_file.
    It is assumed that both files are already open.
    I recommend openning the file with mode='r+' to make your life easy.
    """
    this_new_file = csv.writer(new_file, delimiter=',')
    this_old_file = csv.reader(old_file, delimiter=',')
    for row in this_old_file:
        if row[0] != "new":
            print(f"row {row} is a problem")
        this_new_file.writerow(row)
    new_file.seek(0)
    old_file.seek(0)


def count_csv_rows(csvfile):
    """
    Counts all of the rows in csvfile.
    csvfile is assumed to be already open.
    """
    csvfile.seek(0)
    csvreader = csv.reader(csvfile, delimiter=',')
    count = 0
    for row in csvreader:
        if row[0] != "new":
            print(f"row {row} is a problem for count:{count}")
        count += 1
    csvfile.seek(0)
    print("count=", count)
    return count


def jobfunnel_easy_apply(output_file, input_file, status, number_of_times):
    """
    This modeule integrates and uses JobFunnel. It is especifically designed to work with JobFunnel.
    It will randomly open up as many tabs as you tell it to on your browser from your master_list file that
    is generated by JobFunnel. It will also mark each one of the randomly selected rows with a status you give it.
    The default status is 'archive'. After running the easy_apply function, you should see a "updated_master_list.csv" file
    on the same directory you ran the script on. And your master_list.csv file should have some updated rows with
    the status you passed.
    Hope it helps you on your job hunting as much as it has helped me :).
    """
    print("running jobfunnel_easy_apply:",[output_file,input_file,status,number_of_times])
    return
    # args = parser.parse_args()
    input_file = args.input
    output_file = args.output
    status = args.status
    if not(status.lower() in ["archive", "interview", "offer"]):
        print("invalid status")
        print("Must pass one of these as as status:",["archive", "interview", "offer"] )
        return
    number_of_times = int(args.number_of_times)
    if number_of_times>=30:
        print(f"Are you sure you want to open {number_of_times} tabs on your browser? This could make a low-spec system crash.\n \
               To go on, type 'y' and ENTER to proceed. Type 'n' to cancel this session.")
        answer = input()
        if(answer.lower() != 'y'):
            return
    csvfile = open(input_file ,mode='r+')
    row_nums = []
    for i in range(number_of_times):
        row_num  = random.randint(1, count_csv_rows(csvfile))

        while(row_num in row_nums):
            row_num  = random.randint(1, count_csv_rows(csvfile))
        row_nums.append(row_num)
    csvfile.seek(0)
    does_output_file_exist = os.path.exists(output_file)
    new_csv = None
    csvreader2 = csv.reader(csvfile, delimiter=',')
    if(not(does_output_file_exist)):
        new_csv = open(output_file, mode='a+')
        new_csv.close()
    new_csv = open(output_file, mode='r+')
    new_csv.seek(0)
    csvwriter = csv.writer(new_csv)
    count = 0
    for row in csvreader2:
        if(count in row_nums):
            link = extract_link(row)
            webbrowser.open(link)
            row[0] = status
            print(f"row with link {link} has been marked '{status}'")
        csvwriter.writerow(row)
        count +=1
    # print("output_file:", new_csv.read())
    csvfile.seek(0)
    new_csv.seek(0)
    csvfile.truncate(0)
    csvfile.seek(0)
    csvwriter = csv.writer(csvfile, delimiter=',')
    csvreader = csv.reader(new_csv, delimiter=',')
    for row in csvreader:
        csvwriter.writerow(row)
    print(f"{input_file} has been overwritten with the contents of {output_file}")
    csvfile.close()
    new_csv.close()











def standalone_easy_apply():
    """
    This modeule integrates and uses JobFunnel. It is especifically designed to work with JobFunnel.
    It will randomly open up as many tabs as you tell it to on your browser from your master_list file that
    is generated by JobFunnel. It will also mark each one of the randomly selected rows with a status you give it.
    The default status is 'archive'. After running the easy_apply function, you should see a "updated_master_list.csv" file
    on the same directory you ran the script on. And your master_list.csv file should have some updated rows with
    the status you passed.
    This "standalone" version for those who want to experiment and run it directly from the command line :).
    Hope it helps you on your job hunting as much as it has helped me :).
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-o","--output", help="The contents of the new csv are dumped onto this file. The default is 'updated_master_list.csv'",
                        default='updated_master_list.csv')
    parser.add_argument("-i","--input", help="This is the csv that is getting scanned. The default value is 'master_list.csv'",
                        default='master_list.csv')
    parser.add_argument("-s","--status", help="The new status the random jobs will be marked with. The default is 'archive'.",
                        default='archive')
    parser.add_argument("-n","--number_of_times", help="Number of jobs to apply to",default=1)
    args = parser.parse_args()
    input_file = args.input
    output_file = args.output
    status = args.status
    if not(status.lower() in ["archive", "interview", "offer"]):
        print("invalid status")
        print("Must pass one of these as as status:",["archive", "interview", "offer"] )
        return
    number_of_times = int(args.number_of_times)
    if number_of_times>=30:
        print(f"Are you sure you want to open {number_of_times} tabs on your browser? This could make a low-spec system crash.\n \
               To go on, type 'y' and ENTER to proceed. Type 'n' to cancel this session.")
        answer = input()
        if(answer.lower() != 'y'):
            return
    csvfile = open(input_file ,mode='r+')
    row_nums = []
    for i in range(number_of_times):
        row_num  = random.randint(1, count_csv_rows(csvfile))

        while(row_num in row_nums):
            row_num  = random.randint(1, count_csv_rows(csvfile))
        row_nums.append(row_num)
    csvfile.seek(0)
    does_output_file_exist = os.path.exists(output_file)
    new_csv = None
    csvreader2 = csv.reader(csvfile, delimiter=',')
    if(not(does_output_file_exist)):
        new_csv = open(output_file, mode='a+')
        new_csv.close()
    new_csv = open(output_file, mode='r+')
    new_csv.seek(0)
    csvwriter = csv.writer(new_csv)
    count = 0
    for row in csvreader2:
        if(count in row_nums):
            link = extract_link(row)
            webbrowser.open(link)
            row[0] = status
            print(f"row with link {link} has been marked '{status}'")
        csvwriter.writerow(row)
        count +=1
    # print("output_file:", new_csv.read())
    csvfile.seek(0)
    new_csv.seek(0)
    csvfile.truncate(0)
    csvfile.seek(0)
    csvwriter = csv.writer(csvfile, delimiter=',')
    csvreader = csv.reader(new_csv, delimiter=',')
    for row in csvreader:
        csvwriter.writerow(row)
    print(f"{input_file} has been overwritten with the contents of {output_file}")
    csvfile.close()
    new_csv.close()
