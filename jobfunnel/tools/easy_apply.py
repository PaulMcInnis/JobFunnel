import csv
import subprocess
import random
import webbrowser
import sys
import argparse
import os


def extract_link(row):
    """
    extracts the application link from a csv row.
    """
    return row[len(row)-4]


def duplicate_csv(new_file, old_file):
    """
    This takes the contents of old_file and dumps them onto new_file.
    It is assumed that both files are already open.
    I recommend openning the file with mode='r+' to make your life easy.
    """
    this_new_file = csv.writer(new_file, delimiter=',')
    this_old_file = csv.reader(old_file, delimiter=',')
    for row in this_old_file:
        this_new_file.writerow(row)
    new_file.seek(0)
    old_file.seek(0)


def count_csv_rows(csvfile):
    """
    Counts all of the rows in csvfile.
    csvfile is assumed to be already open.
    """
    csvfile.seek(0)
    csvreader = csv.reader(csvfile, delimiter=',')
    count = 0
    for row in csvreader:
        count += 1
    csvfile.seek(0)
    print("count=", count)
    return count

def get_not_new_list(csvfile):
    csvfile.seek(0)
    csvreader = csv.reader(csvfile, delimiter=',')
    not_new = []
    count = 0
    for row in csvreader:
        if row[0] != "new":
            not_new.append(count)
        count += 1
    csvfile.seek(0)
    return not_new

def easy_apply(output_file, input_file, status, number_of_times):
    """
    This modeule integrates and uses JobFunnel. It is especifically designed to work with JobFunnel.
    It will randomly open up as many tabs as you tell it to on your browser from your master_list file that
    is generated by JobFunnel. It will also mark each one of the randomly selected rows with a status you give it.
    The default status is 'archive'. After running the easy_apply function, you should see a "updated_master_list.csv" file
    on the same directory you ran the script on. And your master_list.csv file should have some updated rows with
    the status you passed.
    Hope it helps you on your job hunting as much as it has helped me :).
    """
    print("running jobfunnel_easy_apply:",[output_file,input_file,status,number_of_times])
    # args = parser.parse_args()

    if not(status.lower() in ["archive", "interview", "offer", "new"]):
        print("invalid status")
        print("Must pass one of these as status:",["archive", "interview", "offer"] )
        return
    number_of_times = int(number_of_times)
    if number_of_times>=30:
        print(f"Are you sure you want to open {number_of_times} tabs on your browser? This could make a low-spec system crash.\n \
               To go on, type 'y' and ENTER to proceed. Type 'n' to cancel this session.")
        answer = input()
        if(answer.lower() != 'y'):
            return
    csvfile = open(input_file ,mode='r+')
    not_new_list  = get_not_new_list(csvfile)
    csv_row_count = count_csv_rows(csvfile)
    if(len(not_new_list) == csv_row_count):
        print("Congrats! You've applied to all the jobs on the list.\
               Run JobFunnel again to get more jobs on your master list")
        return
    row_nums = []
    for i in range(number_of_times):
        row_num  = random.randint(1, csv_row_count)
        while((row_num in row_nums) or (row_num in not_new_list)):
            row_num  = random.randint(1, csv_row_count)
        row_nums.append(row_num)
    csvfile.seek(0)
    does_output_file_exist = os.path.exists(output_file)
    new_csv = None
    csvreader2 = csv.reader(csvfile, delimiter=',')
    if(not(does_output_file_exist)):
        new_csv = open(output_file, mode='a+')
        new_csv.close()
    new_csv = open(output_file, mode='r+')
    new_csv.seek(0)
    csvwriter = csv.writer(new_csv)
    count = 0
    for row in csvreader2:
        if(count in row_nums):
            link = extract_link(row)
            webbrowser.open(link)
            row[0] = status
            print(f"row with link {link} has been marked '{status}'")
        csvwriter.writerow(row)
        count +=1
    csvfile.seek(0)
    new_csv.seek(0)
    csvfile.truncate(0)
    csvfile.seek(0)
    csvwriter = csv.writer(csvfile, delimiter=',')
    csvreader = csv.reader(new_csv, delimiter=',')
    for row in csvreader:
        csvwriter.writerow(row)
    print(f"{input_file} has been overwritten with the contents of {output_file}")
    not_new_count = len(get_not_new_list(csvfile))
    print(f"Job Application completion:{ ( ((not_new_count)/csv_row_count)*100):.1f}%")
    csvfile.close()
    new_csv.close()
